# 1️⃣ Week 1 (Section 1 ~ Section 2)

### 😶 Cluster Architecture

- `Worker Nodes`
    - `클러스터`에서 실제 애플리케이션이 실행되는 물리적 또는 가상 머신을 의미한다.
    - `쿠버네티스`의 핵심 구성 요소 중 하나이며, 애플리케이션 컨테이너를 실행하고 관리하는 데 필요한 모든 서비스를 제공한다.

- `Master Node`
    - `클러스터`의 제어 영역을 담당하고, 클러스터의 상태를 관리한다.
    - 작업 부하를 스케줄링하며, 전체적인 `오케스트레이션`을 수행하는 역할을 한다.

- `ETCD Cluster`
    - 분산 `Key-Value Store`로, 클러스터의 모든 구성 데이터를 저장한다.
    - `클러스터`의 현재 상태, 구성 정보, 시크릿 및 설정 등을 저장하며, 강력한 `일관성`과 `가용성`을 보장한다.
    - 모든 마스터 구성 요소는 `etcd`를 통해 데이터를 저장하고 검색한다.

- `Kube-Scheduler`
    - `클러스터` 내에서 `Pod`를 실행할 적절한 노드를 결정하는 역할을 한다.
    - `스케줄러`는 리소스 사용량, 정책, 노드 상태 등을 고려하여 최적의 노드를 선택한다.
    - 각 `Pod`의 배치 결정을 통해 클러스터의 `리소스 효율성`을 극대화 한다.

- `Node-Controller`
    - `클러스터` 내의 노드 상태를 `모니터링`하고 `관리`한다.
    - `노드`의 상태 변경을 처리하고, 비정상적인 `노드`의 `Pod`를 다시 스케줄링 한다.

- `Kube-Controller-Manager`
    - 다양한 `컨트롤러`들을 실행하는 `데몬`이다.
    - 주요 `컨트롤러`에는 **ReplicatoinController**, **NodeController**, **EndPointsController**, **ServiceAccountController** 등이 있다.
    - 각 `컨트롤러`는 클러스터의 원하는 상태와 `실제 상태`를 비교하고, 필요한 경우 조치를  취하여 `상태`를 `일치`시키는 작업을 수행한다.

- `Replication-Controller`
    - 특정 수의 `Pod`가 항상 실행되도록 보장한다.
    - `Pod`의 복제, 삭제 및 `재스케줄링`을 관리하며 애플리케이션의 가용성을 유지한다.

- `Kube-apiserver`
    - `쿠버네티스 API` 서버로, 클러스터의 중심 인터페이스이다.
    - 모든 클라이언트와의 상호 작용은 `API 서버`를 통해 이루어진다.
    - API 서버는 `Restful API`를 제공하며, 클러스터의 모든 상태 변경 요청을 처리한다.

- `Kubelet`
    - `Kubelet`은 `Worker Node`에서 실행되는 에이전트이다.
    - `Pod`(컨테이너 그룹)의 생성을 요청하고, 이들을 `노드`에서 실행하고 모니터링 한다.

- `Kube-proxy`
    - `Kube-proxy`는 네트워크 프록시 및 `로드 밸런서` 역할을 한다.
    - 각 `노드`에서 실행되며, `쿠버네티스` 서비스의 네트워크 규칙을 관리하여 클러스터 내에서 서비스 간의 통신을 가능하게 한다.
    - IP 주소와 `포트`를 기반으로 트래픽을 전달하고, `로드 밸런싱`을 수행한다.

- `Container Runtime Engine`
    - `컨테이너 런타임`은 컨테이너를 실행하고 관리하는 소프트웨어입니다.
    - `Docker`, `containerd`, `CRI-O` 등이 일반적으로 사용된다.
    - `kubelet`은 컨테이너 `런타임`과 상호 작용하여 컨테이너를 시작하고 중지한다.

### 👿 Docker vs Containerd

- `ctr`
    - `containerd`의 **CLI 도구**이다.
    - 주요 기능으로는 컨테이너 이미지 관리, 이미지 풀 등이 있다.
    
    ```sql
    # 명령어 예시
    ctr image pull docker.io/library/nginx:latest
    
    ctr run --rm -t docker.io/library/nginx:latest
    
    ctr container list
    ```
    
- `nerdctl`
    - `Docker`와 호환되는 CLI로, `containerd`를 백엔드로 사용한다.
    - `Docker` 사용자들이 **익숙한 명령어를 사용**하여 `containerd`를 쉽게 사용할 수 있도록 설계되었다.
    
    ```sql
    # 명령어 예시
    nerdctl pull nginx:latest
    
    nerdctl run -d --name mynginx nginx:latest
    
    nerdctl ps
    ```
    
- `crictl`
    - `쿠버네티스`에서 사용되는 `CRI` 호환 컨테이너 런타임을 관리하기 위한 **CLI 도구**다.
    - `쿠버네티스` 클러스터에서 컨테이너 런타임을 **디버깅하고 관리**하는 데 사용된다.
    
    ```sql
    # 명령어 예시
    crictl pods
    
    crictl inspect <Container ID>
    
    crictl logs <Container ID>
    ```
    
- `CRI(Container Runtime Interface)`
    - `쿠버네티스`와 컨테이너 런타임 간의 `표준 인터페이스`로, 다양한 `런타임`을 지원하고 통합한다.

- `OCI (Open Container Initiative)`
    - 컨테이너 이미지 및 `런타임`의 표준을 정의하여, `호환성`과 상호 운용성을 보장한다.

- `Dockershim`
    - `쿠버네티스`에서 `Docker`를 사용하기 위한 중간 계층으로, CRI 도입 이전에 `Docker`와의 호환성을 유지하기 위해 사용되었다.
    - 현재는 `사용 중단`되었다.

### 😀 Object

- `Pod`
    - `Pod`는 `쿠버네티스`에서 가장 작은 배포 단위로, 하나 이상의 컨테이너를 포함하는 `논리적 호스팅` 단위다.
    - `Pod`에 포함된 `컨테이너`들은 항상 같은 노드에서 실행되며, 동일한 네트워크 `네임스페이스`와의 볼륨을 공유한다.

- `Yaml 작성`
    - `Yaml 파일`은 리소스를 정의할 때 사용된다.
    
    ```yaml
    # 예시
    
    # 리소스가 속한 API 그룹과 버전을 정의
    apiVersion: v1
    # 생성하려는 쿠버네티스 리소스의 종류를 정의
    kind: Pod
    # 리소스의 이름, 네임스페이스, 레이블 등의 메타데이터를 정의
    metadata:
      name: my-pod
      labels:
        apps: my-app
    # 리소스의 원하는 상태를 정의
    spec:
      containers:
        - name: my-container
          image: nginx:latest
          ports:
            - containerPort: 80
        
        volumes:
        - name: my-volume
          emptyDir: {}
    ```
    

- `ReplicaSet`
    - 특정 수의 동일한 `Pod` 복제본이 **항상 실행되도록 보장**한다.
    - `Pod`의 생성 및 삭제를 관리하여 **원하는 수의 복제본을 유지**한다.
    - `주요 기능`
        - 복제본 관리
        - 자동 복구
        - 라벨 셀렉터
            - 라벨 셀렉터를 사용하여 관리할 Pod를 선택하고 특정 라벨을 가진 Pod만 ReplicaSet에 의해 관리된다.

- `Deployments`
    - `ReplicaSet`을 기반으로 한 **상위 수준의 리소스**로, 애플리케이션의 선언적 업데이트를 관리한다.
    - 새로운 `ReplicaSet`을 생성하고, 점진적으로 이전 `ReplicaSet`을 교체하여 **애플리케이션의 롤링 업데이트를 수행**한다.
    - 대부분의 경우 `ReplicaSet` 보다는 `Deployment`를 사용하는 것이 일반적이다.
    - `주요 기능`
        - 롤링 업데이트
        - 자동 롤백
        - 확장 및 축소
        - 이력 관리
            - `애플리케이션`의 배포 이력을 관리하여, 이전 버전으로 롤백할 수 있다.
    

### 😧 Services

- `NodePort`
    - `클러스터 외부`에서 서비스에 접근할 수 있도록 각 `노드`의 특정 포트를 열어주는 `서비스 타입`이다.
    - `클러스터`의 모든 노드에서 동일한 포트를 열어 `외부 트래픽`을 받아들이며, 내부의 `ClusterIP` 서비스로 전달한다.
    - `특징`
        - 외부 접근 가능
        - 고정 포트 (30000 - 32767 범위 내에서 할당)
        - 자동 생성 (내부적으로 **ClusterIP 서비스를 자동으로 생성**해서 관리)
- `ClusterIP`
    - `쿠버네티스`에서 기본적으로 제공하는 서비스 타입으로, 클러스터 내부에서만 접근 가능한 `가상 IP 주소`를 할당한다.
    - 외부에서 직접 접근할 수 없으며, `클러스터` 내의 다른 서비스나 `Pod`만이 접근할 수 있다.
    - `특징`
        - 내부 통신
        - 내부 DNS
- `LoadBalancer`
    - 클라우드 제공자의 `로드 밸런서`를 사용하여 서비스에 외부 트래픽을 분산시키는 `서비스 타입`이다.
    - 외부에 `고정 IP` 주소를 제공하며, **클러스터 외부에서 접근**할 수 있다.
    - `특징`
        - 클라우드 통합
        - 고정 IP 제공
        - 자동 생성 (내부적으로 **NodePort와 ClusterIP 서비스를 자동으로 생성**하여 관리)

### 😐 Namespace

- `NameSpace`
    - 동일한 클러스터 내에서 여러 가상 클러스터를 지우너하기 위해 사용되는 논리적인 분리 단위다.
    - `리소스`를 그룹화하고 **관리 및 접근 제어를 단순화**할 수 있다.
    - `주요 기능`
        - 리소스 분리
            - 각 `Namespace`는 고유한 **리소스 세트**를 가진다.
        - 접근 제어
            - `RBAC`와 결합하여 사용자가 접근할 수 있는 **Namespace와 수행할 수 있는 작업을 정의**할 수 있다.
        - 리소스 할당 및 제한
            - `리소스 쿼터`와 `제한(Limits)`을 설정할 수 있다.
            - **CPU, 메모리** 등의 리소스를 팀이나 프로젝트 별로 `제한`할 수 있다.
        - 관리 편의성 제공
            - 여러 팀이나 프로젝트가 `동일한 클러스터` 사용시, 관리 작업을 **논리적으로 분리하여 편리하게 수행**할 수 있다.
            - `네트워크 정책`을 Namespace 별로 정의하여 **트래픽을 제어**할 수 있다.
- `기본 Namespace`
    - `default`
        - 사용자가 **특별히 지정하지 않은 리소스**가 생성된다.
    - `kube-system`
        - **쿠버네티스 시스템 구성 요소**가 위치하는 `Namespace`
        - **kube-dns, kube-proxy** 등의 리소스가 위치한다.
    - `kube-public`
        - `클러스터` 내 모든 사용자가 **읽을 수 있는 리소스를 포함**한다.
        - `클러스터 정보`와 같은 **공개적인 데이터**를 저장한다.

### 🤓 ETC..

- `Imperative vs Declarative`
    - `명령형 관리 (Imperative Management)`
        - 관리자가 **특정 명령을 직접 명령하여 실행하는 방식**이다.
        - 주요 특징
            - `직접 명령`
                - 사용자는 특정 작업을 수행하는 명령을 직접 실행한다.
            - `단일 작업`
                - 각 명령은 단일 작업을 수행한다.
            - `빠른 적용`
                - 즉시 작업을 실행하고, 결과를 즉각적으로 확인할 수 있다.
    
    - `선언적 관리 (Declarative Management)`
        - 주요 특징
            - `최종 상태 선언`
                - 사용자는 **리소스의 원하는 상태를 파일에 정의**한다.
                - `쿠버네티스`는 이 파일을 읽어 **실제 상태를 선언된 상태와 일치시키기 위해 필요한 작업을 수행**한다.
            - `상태 관리`
                - `선언적 관리`는 리소스의 상태를 **자동으로 관리**한다.
                - `GitOps`와 같은 **지속적 배포 방식에 적합**하다.
            - `재사용성 및 일관성`
                - `Yaml 파일`을 통해 리소스 구성을 문서화하고, 쉽게 버전 관리를 할 수 있다.
                - 여러 환경에서 `동일한 구성`을 **재사용**할 수 있다.
    
    `명령형 관리`는 **빠른 수정과 테스트**에 적합하고, `선언적 관리`는 **복잡한 시스템의 일관된 상태 유지**와 버전 관리에 더 효과적이다.
    
- `Create vs Apply`
    - `Create`
        - `새로운 리소스 생성`
            - `kubectl create`는 리소스를 처음 생성할 때 사용된다.
            - 이미 존재하는 `리소스`에 대해 실행하면 **에러가 발생**한다.
        - `일회성 작업`
            - 특정 리소스를 `한 번 생성`하고 이후에는 **리소스를 직접 관리하거나 업데이트** 해야 한다.

- `Apply`
    - `리소스 생성 및 업데이트`
        - 새로운 리소스를 생성할 뿐 아니라, **기존 리소스를 업데이트 하는 데에도 사용**된다.
        - 이미 `존재하는 리소스`를 업데이트 할 때는 **변경된 부분만을 적용**한다.
    - `선언적 관리`
        - Yaml 또는 JSON 파일에 정의된 `최종 상태`를 클러스터에 적용하여, **현재 상태를 일치**시킨다.
    - `상태 유지 및 복구`
        - `리소스`의 상태가 변경되거나 삭제되었을 경우, `kubectl apply` 를 다시 실행하여 **원하는 상태로 복구**할 수 있다.

`create`는 새로운 리소스를 빠르게 생성할 때 유용하며, `apply`는 **리소스의 지속적인 상태관리**를 위해 더 나은 선택이다.
